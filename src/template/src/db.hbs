{{#if is_sqlx}}
{{#if is_mysql}}
use sqlx::MySqlPool;
{{/if}}
{{#if is_postgres}}
use sqlx::PgPool;
{{/if}}
{{#if is_sqlite}}
use sqlx::SqlitePool;
{{/if}}
{{/if}}
{{#if is_sea_orm}}
use std::time::Duration;
use sea_orm::{entity::prelude::DatabaseConnection, ConnectOptions, Database};
{{/if}}
use tokio::sync::OnceCell;

use crate::config::CFG;
{{#if is_sqlx}}
{{#if is_sqlite}}
pub static DB: OnceCell<SqlitePool> = OnceCell::const_new();
{{/if}}
{{#if is_postgres}}
pub static DB: OnceCell<PgPool> = OnceCell::const_new();
{{/if}}
{{#if is_mysql}}
pub static DB: OnceCell<MySqlPool> = OnceCell::const_new();
{{/if}}
pub async fn init_db_conn() {
    DB.get_or_init(|| async {
        {{#if is_sqlx}}
        {{#if is_sqlite}}
        SqlitePool::connect(&CFG.database.database_url)
            .await
            .expect("{{database_connection_failed}}")
        {{/if}}
        {{#if is_postgres}}
        PgPool::connect(&CFG.database.database_url)
            .await
            .expect("{{database_connection_failed}}")
        {{/if}}
        {{#if is_mysql}}
        MySqlPool::connect(&CFG.database.database_url)
        .await
        .expect("{{database_connection_failed}}")
        {{/if}}
        {{/if}}
    })
    .await;
}
{{/if}}

{{#if is_sea_orm}}
pub static DB: OnceCell<DatabaseConnection> = OnceCell::const_new();

pub async fn init_db_conn() {
	DB.get_or_init(|| async {
		let mut opt = ConnectOptions::new(CFG.database.database_url.to_owned());
		opt.max_connections(1000)
			.min_connections(5)
			.connect_timeout(Duration::from_secs(8))
			.idle_timeout(Duration::from_secs(8))
			.sqlx_logging(false);

		Database::connect(opt).await.expect("数据库打开失败")
	})
	.await;
}
{{/if}}