{{#if is_sqlx}}
use crate::{
    app_error::AppResult,
    db::DB,
    dtos::user::{
        UserAddRequest, UserDeleteRequest, UserLoginRequest, UserLoginResponse, UserResponse,
        UserUpdateRequest,
    },
    middleware::jwt::get_token,
    entities::user::User,
    utils::rand_utils,
};
{{/if}}
{{#if is_sea_orm}}
use crate::{
    app_error::AppResult,
    db::DB,
    dtos::user::{
        UserAddRequest, UserDeleteRequest, UserLoginRequest, UserLoginResponse, UserResponse,
        UserUpdateRequest,
    },
    middleware::jwt::get_token,
    entities::{prelude::User,user},
    utils::rand_utils,
};
use sea_orm::{EntityTrait, Set, ActiveModelTrait, QueryFilter, ColumnTrait};
{{/if}}
use uuid::Uuid;
{{#if is_sqlx}}
pub async fn add_user(req: UserAddRequest) -> AppResult<UserResponse> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let id = Uuid::new_v4().to_string();
    let hash_password = rand_utils::hash_password(req.password).await?;
    let _ = sqlx::query!(
        r#"
            INSERT INTO users (id, username, password)
            VALUES ($1, $2, $3)
            "#,
        id,
        req.username,
        hash_password,
    )
    .execute(db)
    .await?;

    Ok(UserResponse {
        id,
        username: req.username,
    })
}

pub async fn login(req: UserLoginRequest) -> AppResult<UserLoginResponse> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let user = sqlx::query_as!(
        User,
        r#"
            SELECT id, username, password FROM users
            WHERE username = $1
            "#,
        req.username
    )
    .fetch_optional(db)
    .await?;
    if user.is_none() {
        return Err(anyhow::anyhow!("{{user_does_not_exist}}").into());
    }
    let user = user.unwrap();
    if rand_utils::verify_password(req.password, user.password)
        .await
        .is_err()
    {
        return Err(anyhow::anyhow!("{{incorrect_password}}").into());
    }
    let (token, exp) = get_token(user.username.clone(), user.id.clone())?;
    let res = UserLoginResponse {
        id: user.id,
        username: user.username,
        token,
        exp,
    };
    Ok(res)
}

pub async fn update_user(req: UserUpdateRequest) -> AppResult<UserResponse> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let hash_password = rand_utils::hash_password(req.password).await?;
    let _ = sqlx::query!(
        r#"
            UPDATE users
            SET username = $1, password = $2
            WHERE id = $3
            "#,
        req.username,
        hash_password,
        req.id,
    )
    .execute(db)
    .await?;

    Ok(UserResponse {
        id: req.id,
        username: req.username,
    })
}

pub async fn delete_user(req: UserDeleteRequest) -> AppResult<()> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    sqlx::query!(
        r#"
            DELETE FROM users
            WHERE id = $1
            "#,
        req.id,
    )
    .execute(db)
    .await?;

    Ok(())
}

pub async fn users() -> AppResult<Vec<UserResponse>> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let users = sqlx::query_as!(
        User,
        r#"
            SELECT id, username, password FROM users
            "#,
    )
    .fetch_all(db)
    .await?;
    let res = users
        .into_iter()
        .map(|user| UserResponse {
            id: user.id,
            username: user.username,
        })
        .collect::<Vec<_>>();
    Ok(res)
}
{{/if}}
{{#if is_sea_orm}}
pub async fn add_user(req: UserAddRequest) -> AppResult<UserResponse> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let model =user::ActiveModel {
        id: Set(Uuid::new_v4().to_string()),
        username: Set(req.username.clone()),
        password: Set(rand_utils::hash_password(req.password).await?),
    };
    let user = User::insert(model).exec(db).await?;
    Ok(UserResponse {
        id: user.last_insert_id,
        username: req.username,
    })
}

pub async fn login(req: UserLoginRequest) -> AppResult<UserLoginResponse> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let user = User::find().filter(user::Column::Username.eq(req.username)).one(db).await?;
    if user.is_none() {
        return Err(anyhow::anyhow!("{{user_does_not_exist}}").into());
    }
    let user = user.unwrap();
    if rand_utils::verify_password(req.password, user.password)
        .await
        .is_err()
    {
        return Err(anyhow::anyhow!("{{incorrect_password}}").into());
    }
    let (token, exp) = get_token(user.username.clone(), user.id.clone())?;
    let res = UserLoginResponse {
        id: user.id,
        username: user.username,
        token,
        exp,
    };
    Ok(res)
}

pub async fn update_user(req: UserUpdateRequest) -> AppResult<UserResponse> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;

    let user = User::find_by_id(req.id).one(db).await?;
    if user.is_none() {
        return Err(anyhow::anyhow!("{{user_does_not_exist}}").into());
    }
    let mut user: user::ActiveModel = user.unwrap().into();

    user.username = Set(req.username.to_owned());
    user.password = Set(rand_utils::hash_password(req.password).await?);

    let user: user::Model = user.update(db).await?;

    Ok(UserResponse {
        id: user.id,
        username: user.username,
    })
}

pub async fn delete_user(req: UserDeleteRequest) -> AppResult<()> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    User::delete_by_id(req.id, ).exec(db).await?;
    Ok(())
}

pub async fn users() -> AppResult<Vec<UserResponse>> {
    let db = DB.get().ok_or(anyhow::anyhow!("{{database_connection_failed}}"))?;
    let users = User::find().all(db).await?;
    let res = users
        .into_iter()
        .map(|user| UserResponse {
            id: user.id,
            username: user.username,
        })
        .collect::<Vec<_>>();
    Ok(res)
}
{{/if}}